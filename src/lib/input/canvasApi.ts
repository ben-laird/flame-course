import { GraphQLClient, Variables } from "graphql-request";
import { z } from "zod";

// TODO Finish implementing ways to inject variables into requests

// TODO Add full documentation

/**
 * Declare a schema with a GraphQL request and variables, as well as a Zod validator schema
 * to sanitize and type-secure incoming data.
 */
export interface CanvasQuerySchema<ZVal extends z.Schema> {
  /**
   * The request object stores the GraphQL query string as well as any variables to be inserted.
   */
  req: {
    /**
     * The GraphQL query string
     */
    query: string;
    /**
     * Any variables to be injected into the GraphQL query string
     */
    variables?: Variables;
  };
  val: ZVal;
}

/**
 * Options to customize the CanvasAPI instance
 */
export interface CanvasAPIOptions {
  /**
   * The canvas access token generated by Canvas
   */
  token?: string;
  /**
   * The endpoint to call with the GraphQL query
   */
  endpoint?: string;
}

/**
 * The parameters needed to construct a CanvasAPI object
 */
export type CanvasAPIParams<ZVal extends z.Schema> = [
  query: CanvasQuerySchema<ZVal>,
  options?: CanvasAPIOptions
];

/**
 * Extract the shape of the API response from a CanvasAPI instance.
 * @Note This is the same type as what is inferred when z.infer<T> is invoked.
 * 
 * ```typescript
 * // {
 * //   allcourses: {
 * //     _id: number;
 * //     name: string;
 * //     courseCode: string | null;
 * //   }[]
 * // }
 * type ExampleShape = ShapeInfer<typeof example>;
 * 
 * const example = new CanvasAPI(
    {
      req: {
        query: gql`
          query ExampleQuery {
            allCourses {
              _id
              name
              courseCode
            }
          }
        `,
      },
      val: z.object({
        allCourses: z.array(
          z.object({
            _id: z.string(),
            name: z
              .string()
              .regex(
                /(?:\w{4}\d{3}L?: .+ \(\d{3}\))|(?:\w+)/,
                "Name didn't match regex!"
              ),
            courseCode: z
              .string()
              .regex(
                /(?:\w{4}\d{3}L?_\d{3}_\d{4}\d{2})|(?:[\w ]+)/,
                "Course code didn't match regex!"
              )
              .nullable(),
          })
        ),
      }),
    },
    { token: "xyz", endpoint: "example.com/graphql" }
  );
 * ```
 */
export type ShapeInfer<T extends CanvasAPI<z.Schema>> = T extends CanvasAPI<
  z.Schema,
  infer R
>
  ? R
  : never;

/**
 * A single connection to the Canvas GraphQL API. This class handles sending one static query to the endpoint and caching the response.
 */
export default class CanvasAPI<
  ZVal extends z.Schema,
  APIShape = z.infer<ZVal>
> {
  private canvasEndpoint =
    "https://libertyuniversity.instructure.com/api/graphql";

  private token = process.env.CANVAS_AUTH_TOKEN;

  private query;

  private cache: APIShape | null = null;

  private invalidateInterval = 5000;

  constructor(...params: CanvasAPIParams<ZVal>) {
    const [query, options] = params;

    this.query = query;

    if (options !== undefined) {
      const { endpoint, token } = options;
      if (token !== undefined) this.token = token;
      if (endpoint !== undefined) this.canvasEndpoint = endpoint;
    }
  }

  public callEndpoint = async (gqlVariables?: Variables): Promise<APIShape> => {
    const client = new GraphQLClient(this.canvasEndpoint).setHeader(
      "authorization",
      `Bearer ${this.token}`
    );
    const { req, val } = this.query;
    const { query, variables } = req;

    const vars = gqlVariables !== undefined ? gqlVariables : variables;

    const response = await client.request<APIShape>(query, vars);

    this.cache = response;
    setTimeout(() => (this.cache = null), this.invalidateInterval);

    return val.parse(response) as APIShape;
  };

  public call = async (gqlVariables?: Variables): Promise<APIShape> => {
    if (this.cache !== null) return this.cache;
    else return this.callEndpoint(gqlVariables);
  };
}
