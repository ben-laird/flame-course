import { GraphQLClient } from "graphql-request";
import { z } from "zod";

// DONE Finish implementing ways to inject variables into requests

// DONE Add full documentation

type GqlVars = Record<string, number | string> | undefined;

/**
 * A raw GraphQL query
 */
export interface RawReq<Vars extends GqlVars = undefined> {
  /**
   * The GraphQL query string
   */
  query: string;
  /**
   * Any variables to be injected into the GraphQL query string
   */
  variables?: Vars;
}

export type ReqFunc<ZVal extends z.Schema, Vars extends GqlVars = undefined> = (
  vars: Vars
) => CanvasQuerySchema<ZVal, Vars>;

/**
 * Declare a schema with a GraphQL request and variables, as well as a Zod validator schema
 * to sanitize and type-secure incoming data.
 */
export interface CanvasQuerySchema<
  ZVal extends z.Schema,
  Vars extends GqlVars
> {
  /**
   * The request object stores the GraphQL query string as well as any variables to be inserted.
   */
  req: RawReq<Vars>;
  /**
   * The validation schema to use
   */
  val: ZVal;
}

/**
 * Options to customize the CanvasAPI instance
 */
export interface CanvasAPIOptions {
  /**
   * The canvas access token generated by Canvas
   */
  token?: string;
  /**
   * The endpoint to call with the GraphQL query
   */
  endpoint?: string;
}

/**
 * The parameters needed to construct a CanvasAPI object
 */
export type CanvasAPIParams<ZVal extends z.Schema, Vars extends GqlVars> = [
  query: ReqFunc<ZVal, Vars>,
  options?: CanvasAPIOptions
];

/**
 * Extract the shape of the API response from a CanvasAPI instance.
 * @note This is the same type as what is inferred when `z.infer<T>` is invoked
 * 
 * ```typescript
 * // {
 * //   allcourses: {
 * //     _id: number;
 * //     name: string;
 * //     courseCode: string | null;
 * //   }[]
 * // }
 * type ExampleShape = ShapeInfer<typeof example>;
 * 
 * const example = new CanvasAPI(
    {
      req: {
        query: gql`
          query ExampleQuery {
            allCourses {
              _id
              name
              courseCode
            }
          }
        `,
      },
      val: z.object({
        allCourses: z.array(
          z.object({
            _id: z.string(),
            name: z
              .string()
              .regex(
                /(?:\w{4}\d{3}L?: .+ \(\d{3}\))|(?:\w+)/,
                "Name didn't match regex!"
              ),
            courseCode: z
              .string()
              .regex(
                /(?:\w{4}\d{3}L?_\d{3}_\d{4}\d{2})|(?:[\w ]+)/,
                "Course code didn't match regex!"
              )
              .nullable(),
          })
        ),
      }),
    },
    { token: "xyz", endpoint: "example.com/graphql" }
  );
 * ```
 */
export type ShapeInfer<
  T extends CanvasAPI<z.Schema, Record<string, number | string>>
> = T extends CanvasAPI<z.Schema, infer R> ? R : never;

/**
 * A single connection to the Canvas GraphQL API. This class handles sending one static query to the endpoint and caching the response.
 */
export default class CanvasAPI<
  ZVal extends z.Schema,
  Vars extends GqlVars = undefined,
  APIShape = z.infer<ZVal>
> {
  private canvasEndpoint =
    "https://libertyuniversity.instructure.com/api/graphql";

  private token = process.env.CANVAS_AUTH_TOKEN;

  private query;

  private _cache: APIShape | null = null;

  /**
   * Return the API cache of the most recent request
   */
  public get cache() {
    return this._cache;
  }

  private invalidateInterval = 5000;

  constructor(...params: CanvasAPIParams<ZVal, Vars>) {
    const [query, options] = params;

    this.query = query;

    if (options !== undefined) {
      const { endpoint, token } = options;
      if (token !== undefined) this.token = token;
      if (endpoint !== undefined) this.canvasEndpoint = endpoint;
    }
  }

  private callEndpoint = async (gqlVariables: Vars): Promise<APIShape> => {
    const client = new GraphQLClient(this.canvasEndpoint).setHeader(
      "authorization",
      `Bearer ${this.token}`
    );
    const { req, val } = this.query(gqlVariables);
    const { query, variables } = req;

    const response = await client.request<APIShape>(query, variables);

    this._cache = response;
    setTimeout(() => (this._cache = null), this.invalidateInterval);

    return val.parse(response) as APIShape;
  };

  public call = async (gqlVariables: Vars): Promise<APIShape> => {
    if (this.cache !== null) return this.cache;
    else return this.callEndpoint(gqlVariables);
  };
}
